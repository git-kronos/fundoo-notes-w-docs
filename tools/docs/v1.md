### Fundoo notes(drf) API

**warning:**

Django provide predefined User model. So manipulation of its attribute or cutom user model to replace the default should happen at initial stage of the project.

It is explaned at the latter stage in [authentication](#auth) section

## Git Branch:

## v1/step-1(mbv)

> requirements:

```plaintext
django
djangorestframework
```

1. Commands to create a django project

    ```bash
    mkdir project_name* && cd project_name*
    python -m venv venv
    source ./venv/bin/activate
    pip install -r requirements/main.txt
    django-admin startproject project_name* .
    ```

    **Note:** project_name = core

2. Create a app/module that focus on a spefic portion of the project

    ```bash
    mkdir -p apps/app_name*
    python manage.py startapp app_name* apps/app_name*
    ```

    **Note:** app_name = note

    > `note` app focus on management of `C`reate `R`ead `U`pdate `D`elete note information collected by users(unauthorised as of now)

#### Desc of note app:

1. `apps.note.apps`:

    > `NoteConfig.name = note` -> `NoteConfig.name = apps.note`

2. `core.settings`

    ```python
    INSTALLED_APPS +=[
        'rest_framework',
        'apps.note'
    ]
    ```

3. `apps.note.models`

    ```python
    class Note(models.Model):
        title = models.CharField(max_length=255)
        body = models.TextField()
        owner = models.ForeignKey("auth.User", on_delete=models.CASCADE)
        class Meta:
            db_table = "note"

        def __str__(self) -> str:
            return "Note(%d, %s)" % (self.id, self.title)
    ```

    **Note:**

    - `Meta.db_table` attr: to rename django's default table_name(`app_name.model_name` in lower case) in data base
    - `__str__()`: to change `print(Model*())` result from `model_name* object(id)` to custom representaion value.
    - `models.ForeignKey()` is to establish `OnetoMany`/`ManyToOne` relation ship -`auth.User`: django's prefered way to use model without importing model. format is `app_name.ModelClassName`
        > alternate: can import specefic Model\* and use instade of `auth.User`

4. migrations

    ```bash
    python manage.py makemigrations
    ```

    it will create python script in `app_name*/migrations` that can modify data base table

    ```bash
    python manage.py migrate
    ```

    it execute migrtion files generated by above command

5. `core.urls.py`

    > this is the root url file assigned to `ROOT_URLCONF` key in `settings.py`.

    ```python
    # core.urls
    from django.urls import include
    urlpatterns += [
        path("api/note/", include("apps.note.urls", namespace="note"))
    ]
    ```

    - create `urls.py` in `apps.note` directory

    ```python
    # apps.note.urls

    from django.urls import path
    from apps.note import views

    app_name = "note"
    urlpatterns = [
        path("", views.note_list, name="note-list"),
        path("<int:pk>", views.note_detail, name="note-detail"),
    ]
    ```

    **Note:**

    - in both urls file, value of `namespace` and `app_name` has to be equal. It is used to identify a set of urls. Also to avoid duplicate senario.

    ```bash
    python manage.py createsuperuser
    ```

    - Since `Note` has relationship with User model, above cmd will create supersuer

    > check `apps.note.views`

    **Note:**

    In view file apis are written in method based view.
    Current apis have 1 drawbacks.
    i.e. user data validation
    which can be avoidable by using `pydantic`, `dataclass` module or drf's `Serialization` module(implemented in next branch `Git Branch: v1/step-2(serialization)`)

## v1/step-2(serialization)

> Expalnations about serialization is in `apps.note.serializers` file

> Then check `app.note.views.NoteCRUD` for implementation of serializer in apis

-   Nested serialization
    -   To implement this, `apps.note.models.Profle` proxy model is used.
    -   `apps.note.serializers.ProfileSerializer` is a uses nested serializer with `notes` attr
        and can be verify by the `/api/note/user/':pk'` api result with and without `ProfileSerializer.notes` attr.

## <a id='auth'></a>v1/step-3(authentication)

> requirements:

```text
PyJWT
```

-   Create user app

```bash
mkdir -p ./apps/user
python manage.py startapp user ./apps/user
```

-   In `apps.user.models`, create `User` that will replace default `auth.User` model

```python
from django.apps import apps
from django.contrib.auth.hashers import make_password
from django.contrib.auth.models import AbstractUser
from django.contrib.auth.models import UserManager as BaseUserManager
from django.db import models


# Create your models here.
class UserManager(BaseUserManager):
    def _create_user(self, email, password, **extra_fields):
        """
        Create and save a user with the given email, and password.
        """
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.password = make_password(password)
        user.save(using=self._db)
        return user

    def create_user(self, email=None, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", False)
        extra_fields.setdefault("is_superuser", False)
        return self._create_user(email, password, **extra_fields)

    def create_superuser(self, email=None, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)

        if extra_fields.get("is_staff") is not True:
            raise ValueError("Superuser must have is_staff=True.")
        if extra_fields.get("is_superuser") is not True:
            raise ValueError("Superuser must have is_superuser=True.")

        return self._create_user(email, password, **extra_fields)


class User(AbstractUser):
    # now username is optional
    username = models.CharField(
        max_length=150,
        unique=True,
        help_text=(
            "Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."
        ),
        validators=[AbstractUser.username_validator],
        error_messages={
            "unique": "A user with that username already exists.",
        },
        null=True,
        blank=True,
    )
    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []
    objects = UserManager()
```

-   [Other ways to create User model](https://youtu.be/Ae7nc1EGv-A)
-   Include `AUTH_USER_MODEL = "user.User"` in `core.settings`

**Note:** This module should be created the very begining of the project.
If not then next might fix some issue.

    Recreate database.
    Remove all migration files(only migration file of model connected to User model need to delete).

-   execute:

```bash
python manage.py migrations
python manage.py migrate
```

-   New apis
    -   `/api/register`
    -   `/api/login`
    -   `/api/profile`

`/api/register` api payload:

```json
{
    "email": "user_one@email.com",
    "password": "Password12",
    "first_name": "user",
    "last_name": "one"
}
```

`/api/login` api payload:

```json
{
    "email": "user_one@email.com",
    "password": "Password12"
}
```

`/api/profile` is a token authorised url. url Header must contain `Authorization` key with `bearer` token

```json
{
    "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTE3MDY5OTYsImF1ZCI6ImxvZ2luIiwiZGF0YSI6eyJpZCI6MywiZW1haWwiOiJ1c2VyX3RocmVlQGVtYWlsLmNvbSJ9fQ.S6YERSTsh6POAZRZt40L_lmGT3t1tMNAxsaW32jR2dc"
}
```

By default token `expiration` set to `60 min` and can be change.

```python
# core.settings
JWT_CONFIG = {
    ...
    "exp": timedelta(minutes=60)
}
```

In `/api/profile` api

```python
@decorators.authentication_classes([JwtAuthentication])
def user_profile(request: Request) -> Response:
    ...
```

-   `authentication_classes([JwtAuthentication])` is responsible of authentication

-   note views are now updated with authentication decorator
-   `apps.note.views.update_user_input` used to update payload with `user id` since user id is decided by authentication.

-   These 2 apis can be develop if needed.

    ```python
    path("password_reset", views.change_password, name="change_password"),
    path("set_password", views.set_password, name="set_password"),
    ```

-   Some inbuilt tool canbe used in the module
    ```python
    from django.contrib.auth import authenticate
    from django.contrib.auth.hashers import make_password, check_password
    ```
