### Fundoo notes(drf) API

**warning:**

Django provide predefined User model. So manipulation of its attribute or cutom user model to replace the default should happen at initial stage of the project.

It is explaned at the latter stage in [authentication](#v1step-3authentication) section

## Git Branch:

## v1/step-1(mbv)

> requirements:

```plaintext
django
djangorestframework
```

1. Commands to create a django project

    ```bash
    mkdir project_name* && cd project_name*
    python -m venv venv
    source ./venv/bin/activate
    pip install -r requirements/main.txt
    django-admin startproject project_name* .
    ```

    **Note:** project_name = core

2. Create a app/module that focus on a spefic portion of the project

    ```bash
    mkdir -p apps/app_name*
    python manage.py startapp app_name* apps/app_name*
    ```

    **Note:** app_name = note

    > `note` app focus on management of `C`reate `R`ead `U`pdate `D`elete note information collected by users(unauthorised as of now)

#### Desc of note app:

1. `apps.note.apps`:

    > `NoteConfig.name = note` -> `NoteConfig.name = apps.note`

2. `core.settings`

    ```python
    INSTALLED_APPS +=[
        'rest_framework',
        'apps.note'
    ]
    ```

3. `apps.note.models`

    ```python
    class Note(models.Model):
        title = models.CharField(max_length=255)
        body = models.TextField()
        owner = models.ForeignKey("auth.User", on_delete=models.CASCADE)
        class Meta:
            db_table = "note"

        def __str__(self) -> str:
            return "Note(%d, %s)" % (self.id, self.title)
    ```

    **Note:**

    - `Meta.db_table` attr: to rename django's default table_name(`app_name.model_name` in lower case) in data base
    - `__str__()`: to change `print(Model*())` result from `model_name* object(id)` to custom representaion value.
    - `models.ForeignKey()` is to establish `OnetoMany`/`ManyToOne` relation ship -`auth.User`: django's prefered way to use model without importing model. format is `app_name.ModelClassName`
        > alternate: can import specefic Model\* and use instade of `auth.User`

4. migrations

    ```bash
    python manage.py makemigrations
    ```

    it will create python script in `app_name*/migrations` that can modify data base table

    ```bash
    python manage.py migrate
    ```

    it execute migrtion files generated by above command

5. `core.urls.py`

    > this is the root url file assigned to `ROOT_URLCONF` key in `settings.py`.

    ```python
    # core.urls
    from django.urls import include
    urlpatterns += [
        path("api/note/", include("apps.note.urls", namespace="note"))
    ]
    ```

    - create `urls.py` in `apps.note` directory

    ```python
    # apps.note.urls

    from django.urls import path
    from apps.note import views

    app_name = "note"
    urlpatterns = [
        path("", views.note_list, name="note-list"),
        path("<int:pk>", views.note_detail, name="note-detail"),
    ]
    ```

    **Note:**

    - in both urls file, value of `namespace` and `app_name` has to be equal. It is used to identify a set of urls. Also to avoid duplicate senario.

    ```bash
    python manage.py createsuperuser
    ```

    - Since `Note` has relationship with User model, above cmd will create supersuer

    > check `apps.note.views`

    **Note:**

    In view file apis are written in method based view.
    Current apis have 1 drawbacks.
    i.e. user data validation
    which can be avoidable by using `pydantic`, `dataclass` module or drf's `Serialization` module(implemented in next branch `Git Branch: v1/step-2(serialization)`)

## v1/step-2(serialization)

> Check `apps.note.serializers` for mor details

> Then check `app.note.views.NoteCRUD` for implementation of serializer in apis

-   Nested serialization
    -   To implement this, `apps.note.models.Profle` proxy model is used.
    -   `apps.note.serializers.ProfileSerializer` is a uses nested serializer with `notes` attr
        and can be verify by the `/api/note/user/':pk'` api result with and without `ProfileSerializer.notes` attr.
-   serializers field args `source`:

    ```python
    class NoteSerializer(serializers.ModelSerializer):
        owner_full_name = serializers.CharField(source="owner.get_full_name", read_only=True)
        owner_email = serializers.EmailField(source="owner.email", read_only=True)
        owner_pk = serializers.IntegerField(source="owner.pk", read_only=True)

        class Meta:
            model = Note
            ...
    ```

    **Note**:

    `source` refer to any instance method under the same Model that returns jsonified value or any second degree related(O2O/O2M) attribure.

## v1/step-3(authentication)

1.  ```bash
    pip install PyJWT
    ```

-   Create user app

    ```bash
    mkdir -p ./apps/user
    python manage.py startapp user ./apps/user
    ```

-   In `apps.user.models`, create `User` that will replace default `auth.User` model

    ```python
    ...
    from django.contrib.auth.hashers import make_password
    from django.contrib.auth.models import AbstractUser
    from django.contrib.auth.models import UserManager as BaseUserManager
    from django.db import models


    # Create your models here.
    class UserManager(BaseUserManager):
        def _create_user(self, email, password, **extra_fields):
            ...

        def create_user(self, email=None, password=None, **extra_fields):
            ...

        def create_superuser(self, email=None, password=None, **extra_fields):
            ...


    class User(AbstractUser):
        username = models.CharField(max_length=150, null=True, blank=True, ...)
        USERNAME_FIELD = "email"
        REQUIRED_FIELDS = []
        objects = UserManager()
        ...
    ```

    -   `USERNAME_FIELD` refer to the field used as credentials other than password.

    -   `REQUIRED_FIELDS` is custom feild only for all `django.contrib.auth.models.BaseAbstractUser` derived classes. It's job it to ask mentioned field info at `python manage.py createsuperuser` command execution.

-   [Alternate ways to create User model](https://youtu.be/Ae7nc1EGv-A)

-   Include `AUTH_USER_MODEL = "user.User"` in `core.settings`

**Note:** This module should be created the very begining of the project.
If not then next might fix some issue.

    1.  Recreate database.
    2.  Remove all migration files(only migration file of model connected to User model need to delete).

-   execute:

```bash
python manage.py migrations
python manage.py migrate
```

-   New apis
    -   `/api/register`
    -   `/api/login`
    -   `/api/profile`

`/api/register` api payload:

```json
{
    "email": "user_one@email.com",
    "password": "Password12",
    "first_name": "user",
    "last_name": "one"
}
```

`/api/login` api payload:

```json
{
    "email": "user_one@email.com",
    "password": "Password12"
}
```

`/api/profile` is a token authorised url. url Header must contain `Authorization` key with `bearer` token

```json
{
    "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTE3MDY5OTYsImF1ZCI6ImxvZ2luIiwiZGF0YSI6eyJpZCI6MywiZW1haWwiOiJ1c2VyX3RocmVlQGVtYWlsLmNvbSJ9fQ.S6YERSTsh6POAZRZt40L_lmGT3t1tMNAxsaW32jR2dc"
}
```

By default token `expiration` set to `60 min` and can be change.

```python
# core.settings
JWT_CONFIG = {
    ...
    "exp": timedelta(minutes=60)
}
```

In `/api/profile` api

```python
@decorators.authentication_classes([JwtAuthentication])
def user_profile(request: Request) -> Response:
    ...
```

-   `authentication_classes([JwtAuthentication])` is responsible of authentication

-   note views are now updated with authentication decorator
-   `apps.note.views.update_user_input` used to update payload with `user id` since user id is decided by authentication.

-   These 2 apis can be develop if needed.

    ```python
    path("password_reset", views.change_password, name="change_password"),
    path("set_password", views.set_password, name="set_password"),
    ```

-   Some inbuilt tool canbe used in the module
    ```python
    from django.contrib.auth import authenticate
    from django.contrib.auth.hashers import make_password, check_password
    ```

## v1/step-4(swagger)

1.  dependency: `drf_yasg`

**Note**:
Alternately [DRF inbuild schema](https://www.django-rest-framework.org/api-guide/schemas/) or [drf-spectacular](https://drf-spectacular.readthedocs.io/en/latest/) can be used. [drf-spectacular ref.](https://youtu.be/XBxssKYf5G0)

2.  `core.settings`

    ```python
    INSTALLED_APPS += ['drf_yasg']
    ```

3.  `core.urls`

    ```python
    from drf_yasg.views import get_schema_view
    from rest_framework.permissions import AllowAny

    schema_view = get_schema_view(public=True, permission_classes=(AllowAny,))

    urlpatterns += [ path("docs/", schema_view.with_ui("swagger", cache_timeout=0), name="swagger-ui") ]
    ```

4.  `core.settings`

    ```python
    from drf_yasg import openapi
    SWAGGER_SETTINGS = {
        "USE_SESSION_AUTH": False,
        "DEFAULT_INFO": openapi.Info(
            title="Fundoo Note API",
            default_version="v1",
            description="A test project based on `Google Keep`'s bare minimum functionality for learing `django/djangorestframework`",
        ),
        "SECURITY_DEFINITIONS": {
            "Bearer": {
                "type": "apiKey",
                "name": "Authorization",
                "in": "header"
            },
        },
    }
    ```

    **Note**:

    `USE_SESSION_AUTH`: deactivate django's session auth button from swagger ui.

    `DEFAULT_INFO`: Holds a openapi.Info object where `title` and `default_version` are mandatory args.

    `SECURITY_DEFINITIONS`: can have more than one auth type ([click for reference](https://drf-yasg.readthedocs.io/en/stable/security.html)).

5.  In all api views:

    ```python
    from drf_yasg.utils import swagger_auto_schema

    @swagger_auto_schema(
    method="GET", responses={200: NoteResponseSerializer(many=True)}
    )
    @swagger_auto_schema(
        method="POST",
        request_body=NoteSerializer,
        responses={201: NoteResponseSerializer},
    )
    ...
    def note_list(request: Request) -> Response:
        ...
    ```

    **Note**:

    -   A view can have more than one `swagger_auto_schema` decorator. It depends on difference in rest methods and there responses.

    -   In nested decorator senario, it is mandatory to use this decorator as top level decorator.

    -   By default input space for `post/put` methods were not available. to add space `request_body` arg is needed

    -   `responses` arg can used if a view deals with multiple status code. Here value is a `Serializer` class.

    -   `query_serializer` arg can be used to accept query_params related info. Expected value is a `Serializer` class.

    -   `manual_parameters` used to have api parameter.Expected value is `openapi.Parameter` object. It is a manual way to have param in swager ui.

    ```python
    class NoteSerializer(serializers.ModelSerializer):
        ...
        class Meta:
            swagger_schema_fields = {
                "type": openapi.TYPE_OBJECT,
                "required": ["title", "body"],
                "properties": {
                    "title": openapi.Schema(
                        title="Email subject", type=openapi.TYPE_STRING
                    ),
                    "body": openapi.Schema(
                        title="Email body", type=openapi.TYPE_STRING
                    ),
                },
            }
            model = Note
            ...
    ```

    -   `[Serializer].Meta.swagger_schema_fields` is a way to manipulate visibility of input/output schema in swagger ui. [reff](https://drf-yasg.readthedocs.io/en/stable/custom_spec.html#serializer-meta-nested-class)

    -   `tags` an optional arg used to group apis.
