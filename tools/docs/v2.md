### Fundoo notes(drf) API

Git Branch:

## v2/step-1(api-cbv)

content:

1. API View

    - `rest_framework.view.APIView`
      This is a step-up of `method based view`. While method based view provides fully customisable platform, it
      provides `rest-methods(GET,POST etc.)` based platform. It is the parent class to the rest of
      advance/complex `View` class. It lags features like `pagination_classes`, `serializer_class`, `lookup_field` etc.

      **Note**
      drf-yasg won't work by default in this view class since it lags `serializer_class` and `lookup_field` attr. so
      manual integration is necessary.

2. Generic View

    - `rest_framework.generics.GenericAPIView`
    - `rest_framework.generics.ListCreateAPIView`
    - `rest_framework.generics.RetrieveUpdateDestroyAPIView`
    - etc

   This is 1 layer on top of `APIView`. It has features like `pagination_classes`, `serializer_class`, `lookup_field`,
   which makes it easier to intigrate with `Swagger documentation`.
   It fully customisable but advised to use it algong with mixin classes or use specific generic class
   like `ListAPIView`, `CreateAPIView`, `ListCreateAPIView` etc.

   **Note**
   default `pagination` won't work `GenericAPIView` only. so manually include this feature or inherit `ListAPIView`.
   for more look into `apps.note.NoteListView.post()`

3. Mixins

    1. `rest_framework.mixins.ListModelMixin`
    2. `rest_framework.mixins.CreateModelMixin`
    3. `rest_framework.mixins.DestroyModelMixin`
    4. `rest_framework.mixins.RetrieveModelMixin`
    5. `rest_framework.mixins.UpdateModelMixin`
    6. etc.
       These are the foundation of generic classes. After inheriting these, view will be expose to methods
       like `create`, `list`, `retrieve`, `update`, `destroy` etc of there respective rest-methods.

4. ViewSet

    - `rest_framework.viewsets.ModelViewSet`
    - `rest_framework.viewsets.ViewSet`
    - `rest_framework.viewsets.ReadOnlyModelViewSet`
    - `rest_framework.viewsets.GenericlViewSet`

It is the most flexible class based view in drf library.

It enable multiple instance of rest-method in a single view class.

Look into `apps.note.views.NoteModelViewSet` for implementation

Implementing viewset will break the usual routing structure. So modify regular

```python
urlpatterns = [
    ...
    path("<int:pk>", NoteView.as_view(), name="note-detail"),
    ...
]
# where in detail_views dict all keys are rest-methods and values are associated ViewSet methods.
```

into

```python
detail_views = {"get": "retrieve", "put": "update", "delete": "destroy"}
urlpatterns = [
    ...
    path(
        "<int:pk>",
        NoteModelViewSet.as_view(detail_views),
        name="note-detail",
    ),
    ...
]
# where in detail_views dict all keys are rest-methods and values are associated ViewSet methods.
```

Instead of manually typing all routes, it is better to use `Router`
`DRF` provides 2 router class.
`rest_framework.routers.SimpleRouter`
`rest_framework.routers.DefaultRouter`

while `DefaultRouter()` generate 2 sets of url patterns(with and `withouttrailing_slash`), `SimpleRouter()` only
generate 1 set of url(with `trailing_slash`)
.
Also `DefaultRouter()` urls include response format in it.

e.i.

```python
"""
# DefaultRouter() url
http://localhost:8000/api/note.json

# SimpleRouter() url
http://localhost:8000/api/note
"""
```

#### Router Object

```python
router = routers.SimpleRouter(trailing_slash=False)
router.register(prefix="", viewset=NoteModelViewSet, basename="note")
urlpatterns = router.urls
```

Trailins slash in the url can be controlled by disabling(`trailing_slash=False`) it in the router object.

`prefix`: keyword used in the url prefix to the current route

i.e http://localhost:8000/[prefix-keyword]/regular/route

`basename`: keyword used to name api

```python
# without prefix
router.register(prefix="", viewset=NoteModelViewSet, basename="abc")
path("<int:pk>", NoteModelViewSet.as_view(...), name="[abc]-detail"),

# with prefix
router.register(prefix="xyz", viewset=NoteModelViewSet, basename="abc")
path("xyz/<int:pk>", NoteModelViewSet.as_view(...), name="[abc]-detail"),
```

[Check for more](https://www.django-rest-framework.org/api-guide/routers/)

## v2/step-2(event-driven-dev) ([ref](https://docs.djangoproject.com/en/4.2/topics/signals/))

In django `Signals` are used to achieve `event-listener`/`event-driven archetec`.
Django provides 2 Signal(event) classes out of the
box, `django.dispatch.Signal`, `django.db.models.signals.ModelSignal`, using which custom events/signals can be
generated.

##### Built-in signals([read here](https://docs.djangoproject.com/en/4.2/ref/signals/)):

- Model signals(`django.db.models.signals`)
    - [pre/post]\_init
    - [pre/post]\_save
    - [pre/post]\_delete
    - m2m_changed
- Management signals(`django.db.models.signals`)
    - [pre/post]\_migrate
- Request/response signals(`django.core.signals`)
    - request\_[started/finished]
    - got_request_exception
- Test signals(`django.test.signals`)
    - setting_changed
    - template_rendered
- Database Wrappers(`django.db.backends.signals`)
    - connection_created

##### use-case

```python

"""
receiver
"""

# apps.user.signals
from django.db.models.signals import post_save
from django.dispatch import receiver


@receiver(signal=post_save, sender=User)
def verify_email_id_on_registration(instance, **kwargs):
    ...


"""
registering signal logic to django project
"""

# apps.user.apps
from django.apps import AppConfig
from django.core.signals import request_finished


class UserConfig(AppConfig):
    ...

    def ready(self):
        # Implicitly connect signal handlers decorated with @receiver.
        from . import signals  # noqa

        # Explicitly connect a signal handler.
        request_finished.connect(signals.my_callback)
```

##### custom signal

```python
"""custom signal"""

# apps.utils.__init__
from django.dispatch import Signal

collaborator_signals = Signal()

"""receiver logic"""
# apps.note.signals
from django.dispatch import receiver


@receiver(collaborator_signals)
def collaborator_action(signal, payload, **kwargs):
    ...


"""trigger"""
# apps.note.views.NoteModelViewSet 177:9
collaborator_signals.send(sender=self.__class__, payload={"data": response.data, "action": action})
# [signal].send() : sender param is mandatory, it can be anything., Rest params are optional.
```

[check for more](https://docs.djangoproject.com/en/4.2/ref/signals/)

## v2/step-3(middleware)

[ref](https://docs.djangoproject.com/en/4.2/topics/http/middleware/)

Middleware is a framework of hooks into Django’s request/response processing. It’s a light, low-level “plugin” system
for globally altering Django’s input or output.

custom midddleware

```python
# method based miggleware
def simple_middleware(get_response):
    # One-time configuration and initialization.

    def middleware(request):
        # Code to be executed for each request before
        # the view (and later middleware) are called.

        response = get_response(request)

        # Code to be executed for each request/response after
        # the view is called.

        return response

    return middleware


# class based miggleware
class SimpleMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        # One-time configuration and initialization.

    def __call__(self, request):
        # Code to be executed for each request before
        # the view (and later middleware) are called.

        response = self.get_response(request)

        # Code to be executed for each request/response after
        # the view is called.

        return response
```

Activating middleware

```python
MIDDLEWARE = [
    ...
    path.to.simple_middleware
    path.to.SimpleMiddleware
]
```

Hooks
Django provides 3 hooks to class based
middleware. [check for more](https://youtube.com/playlist?list=PLbw9kI1cQpMrPWG55DmMLEZvRpmldlXMH&si=FHSflLKo29EgGCoA)

```python
# apps.middleware
class LoggingMiddleware:
    ...

    def process_template_response(self, request, response):
        ...

    def process_exception(self, request, exception):
        ...

    def process_view(self, request, view_func, view_args, view_kwargs):
        ...
```

## v2/step-4(manager)

A Manager is the interface through which database query operations are provided to Django models. At least one Manager
exists for every model in a Django application.

Check `apps.user.models.UserManager`, `apps.note.models.NoteManager`

## v2/step-5(custom-command)

[`django.core.management.base.BaseCommand`](https://docs.djangoproject.com/en/4.2/howto/custom-management-commands/)
class can be used to create custom management command in django project.

> <app_name>.management.commands.<`command_name`>.py

**Note** Here every directory in project needs to be a module to be recognised by django.

`BaseCommand` depends on python [`argparse`](https://docs.python.org/3/library/argparse.html) module.

Look into `apps.user.management.commands.populate_db` file for implementation.
